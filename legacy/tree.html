<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SELF BALANCING BINARY SEARCHING TREE</title>
    <a href="/" class="logo-container">
        <img src="ravenclaw.png" alt="Website Logo" class="animated-logo">
      </a>

    <style>
        body {
            font-family: "Times New Roman", Times, serif;
            text-align: center;
            background-color:#0e0414;
        }
        #tree-container {
            width: 100%;
            height: 400px;
            border: 1px solid black;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        @keyframes highlight {
        0% { stroke: transparent; transform: scale(1); }
        50% { stroke: yellow; transform: scale(1.1); }
        100% { stroke: transparent; transform: scale(1); }
    }
    .highlight {
        animation: highlight 1s ease;
        stroke-width: 3px;
    }

        .logo-container {
            position: fixed;
            border-radius: 8px;
            top: 20px;
            right: 20px;
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .animated-logo {
            width: 200px; /*logo size */
            height: auto;
            border-radius: 80px; /*logo border radius*/
            animation: bounce 3s infinite;
        }

        .logo-container:hover {
            transform: scale(1.1);
        }

        @keyframes bounce {
             0%, 100% { transform: translateY(0); }
             50% { transform: translateY(-10px); }
        }

        .animated-heading {
        font-size: 5rem;
        text-align: center;
        background: linear-gradient(45deg, #e7e41e, #ec0063, #e41010);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: float 3s ease-in-out infinite;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        font-family: "Times New Roman", Times, serif;
        transition: transform 0.3s ease;
    }
    @keyframes float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
    }

    .animated-heading
    :hover {
        transform: scale(1.05);
        cursor: pointer;
    }

        body {
    font-family: 'Poppins', sans-serif;
    background-color: #1e1e2e;
    color: white;
    text-align: center;
    padding: 20px;
}

.sub-heading {
    font-family: 'Arial', sans-serif;
    font-size: 18px;
    color: gray;
    text-align: center;
}


.input-container {
    margin-bottom: 20px;
}
input {
    padding: 20px;
    border: none;
    background-color: #ffcc00;
    margin-right: 10px;
    font-weight: bold;
    font-size: 25px;
    border-radius: 1000px;
    font-family: "Gill Sans", sans-serif;
    font-family: 'PixelFont';
    cursor: pointer;
    justify-content: center;
    align-items: center;
}
button {
    background-color: #ffcc00;
    border: none;
    font-size: 25px;
    font-family: "Gill Sans", sans-serif;
    font-family: 'PixelFont';
    padding: 25px 25px;
    border-radius: 25px;
    cursor: pointer;
    font-weight: bold;
    transition: 0.3s;
}
button:hover {
    background-color: #ffaa00;
}
#tree-container {
    width: 60%;
    height: 500px;
    border: 4px solid #ffcc00;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 20px auto;
    background-color: #2e2e3e;
    border-radius: 10px;
    position: relative;
}
svg {
    width: 100%;
    height: 100%;
}

circle {
    fill: #4db8ff; /* Apply a gradient fill */
    stroke: #720f0f; /* Dark stroke for contrast */
    stroke-width: 3px;
    color: black;
    transition: transform 0.4s ease-in-out, fill 0.3s ease-in-out, filter 0.3s ease-in-out;
    filter: drop-shadow(3px 3px 5px rgba(0, 0, 0, 0.3)); /* Adds soft shadow */
}

circle:hover {
    fill: #e7e41e; /* Change to a hover gradient */

    filter: drop-shadow(0px 0px 10px rgba(37, 238, 47, 0.8)); /* Adds a glowing effect */
}
text {
    fill: rgb(15, 1, 1);
    font-weight: bold;
    size: 10px;
}
line {
    stroke: white;
    stroke-width: 4px;
}
circle {
    transition: transform 0.5s ease-in-out;
}

.traversal-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 30px;
}

.traversal-buttons button {
    font-size: 24px;
    font-weight: bold;
    text-transform: uppercase;
    padding: 15px 30px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease-in-out;
    text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
}

/* Preorder Button */
#preorder-btn {
    background: linear-gradient(45deg, #ff4d4d, #ff9900);
    color: white;
    box-shadow: 0px 4px 10px rgba(255, 77, 77, 0.7);
}

#preorder-btn:hover {
    background: linear-gradient(45deg, #ff9900, #ff4d4d);
    transform: scale(1.1);
    box-shadow: 0px 6px 15px rgba(255, 77, 77, 1);
}

/* Inorder Button */
#inorder-btn {
    background: linear-gradient(45deg, #4db8ff, #0073e6);
    color: white;
    box-shadow: 0px 4px 10px rgba(77, 184, 255, 0.7);
}

#inorder-btn:hover {
    background: linear-gradient(45deg, #0073e6, #4db8ff);
    transform: scale(1.1);
    box-shadow: 0px 6px 15px rgba(77, 184, 255, 1);
}

/* Postorder Button */
#postorder-btn {
    background: linear-gradient(45deg, #66bb6a, #2e7d32);
    color: white;
    box-shadow: 0px 4px 10px rgba(102, 187, 106, 0.7);
}

#postorder-btn:hover {
    background: linear-gradient(45deg, #2e7d32, #66bb6a);
    transform: scale(1.1);
    box-shadow: 0px 6px 15px rgba(102, 187, 106, 1);
}


#tree-container {
    width: 100%;
    height: 500px;
    border: 2px solid #ffcc00;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 20px;
    font-family: "Gill Sans", sans-serif;
    font-family: 'PixelFont';
    background-color: #2e2e3e;
    border-radius: 10px;
    box-shadow: 0px 10px 20px rgba(255, 204, 0, 0.3);
    overflow: hidden;
    position: relative;
}


#explanation-panel {
    width: 80%;
    margin: 20px auto;
    padding: 10px;
    border: 2px solid black;
    background-color: #383838;
    box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
    text-align: left;
    border: 2px solid #ffcc00;
    font-size: 18px;
    color: white;
}
    </style>
</head>
<body>
    <h1 class="animated-heading">Binary Search Tree Visualizer</h1>
   
    <input type="number" id="value" placeholder="Enter a number">
    <button onclick="insertNode()">Insert</button>
    <button onclick="deleteNode()">Delete</button>
    <button onclick="searchNode()">Search</button>
    <div class="traversal-buttons">
        <button id="preorder-btn" onclick="showExplanation('preorder')">Preorder Traversal</button>
        <button id="inorder-btn" onclick="showExplanation('inorder')">Inorder Traversal</button>
        <button id="postorder-btn" onclick="showExplanation('postorder')">Postorder Traversal</button>
    </div>
    
    <div id="explanation-panel">
        <h2>Traversal Explanation</h2>
        <p id="explanation-text">Click a traversal button to see the explanation.</p>
    </div>
    
<div id="tree-container"></div>



    

    <script>
        
         function showExplanation(type) {
            let explanation = '';

            if (type === 'inorder') {
                explanation = "Inorder Traversal: Left → Root → Right. This traversal visits the left subtree first, then the root node, and finally the right subtree. Follow the color and note the sequence it traces !";
            } else if (type === 'preorder') {
                explanation = "Preorder Traversal: Root → Left → Right. This traversal processes the root node first, followed by the left subtree, and then the right subtree. Follow the color and note the sequence it traces !";
            } else if (type === 'postorder') {
                explanation = "Postorder Traversal: Left → Right → Root. This traversal visits the left subtree first, then the right subtree, and finally the root node. Follow the color and note the sequence it traces !";
            }

            document.getElementById('explanation-text').innerText = explanation;
        }
        class Node {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.height = 1;
            }
        }

        class AVLTree {
            constructor() {
                this.root = null;
                this.nodeCount = 0;
            }

            getHeight(node) {
                return node ? node.height : 0;
            }

            insert(node, value) {
                if (!node) {
                    this.nodeCount++;
                    return new Node(value);
                }
                if (value < node.value) {
                    node.left = this.insert(node.left, value);
                } else if (value > node.value) {
                    node.right = this.insert(node.right, value);
                } else {
                    return node;
                }
                return node;
            }

            insertValue(value) {
                if (this.nodeCount >= 100) return;
                this.root = this.insert(this.root, value);
                drawTree();
            }

            deleteNode(node, value) {
                if (!node) return node;
                if (value < node.value) {
                    node.left = this.deleteNode(node.left, value);
                } else if (value > node.value) {
                    node.right = this.deleteNode(node.right, value);
                } else {
                    if (!node.left) return node.right;
                    if (!node.right) return node.left;
                    let temp = this.getMinValueNode(node.right);
                    node.value = temp.value;
                    node.right = this.deleteNode(node.right, temp.value);
                }
                return node;
            }

            getMinValueNode(node) {
                while (node.left) node = node.left;
                return node;
            }

            deleteValue(value) {
                this.root = this.deleteNode(this.root, value);
                drawTree();
            }

            search(node, value) {
                if (!node || node.value === value) return node;
                if (value < node.value) return this.search(node.left, value);
                return this.search(node.right, value);
            }
        }

        
        let avlTree = new AVLTree();

        function insertNode() {
            let value = parseInt(document.getElementById("value").value);
            if (!isNaN(value)) {
                avlTree.insertValue(value);
            }
        }

        function deleteNode() {
            let value = parseInt(document.getElementById("value").value);
            if (!isNaN(value)) {
                avlTree.deleteValue(value);
            }
        }

        function searchNode() {
            let value = parseInt(document.getElementById("value").value);
            if (!isNaN(value)) {
                let found = avlTree.search(avlTree.root, value);
                alert(found ? "Value found in tree!" : "Value not found.");
            }
        }


        

        function drawTree() {
    let container = document.getElementById("tree-container");
    container.innerHTML = "";
    let depth = getTreeDepth(avlTree.root);
    let svgHeight = 100 + depth * 80; // Adjust height based on depth
    let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "800");
    svg.setAttribute("height", svgHeight);
    container.style.height = svgHeight + "px"; // Dynamically adjust container height
    container.appendChild(svg);

    let rootX = 400;
    let rootY = 40;
    let initialOffset = 200;
    
    drawNode(svg, avlTree.root, rootX, rootY, initialOffset);
}

function getTreeDepth(node) {
    if (!node) return 0;
    return 1 + Math.max(getTreeDepth(node.left), getTreeDepth(node.right));
}



        function drawNode(svg, node, x, y, offset) {
    if (!node) return;
    let radius = 30; // Larger radius for better visibility

    if (node.left) {
        let leftX = x - offset;
        let leftY = y + 80; // Increased vertical distance for clarity
        drawBranch(svg, x, y, leftX, leftY);
        drawNode(svg, node.left, leftX, leftY, offset / 1.8);
    }

    if (node.right) {
        let rightX = x + offset;
        let rightY = y + 80; // Keep spacing uniform
        drawBranch(svg, x, y, rightX, rightY);
        drawNode(svg, node.right, rightX, rightY, offset / 1.8);
    }

    drawCircle(svg, x, y, radius, node.value);
}



        function drawBranch(svg, x1, y1, x2, y2) {
    let branch = document.createElementNS("http://www.w3.org/2000/svg", "line");
    branch.setAttribute("x1", x1);
    branch.setAttribute("y1", y1);
    branch.setAttribute("x2", x2);
    branch.setAttribute("y2", y2);
    branch.setAttribute("stroke", "black"); // Change to black for visibility

    branch.setAttribute("stroke-width", "2");

    // Append the branch first so it stays behind
    svg.insertBefore(branch, svg.firstChild);


    setTimeout(() => {
        branch.setAttribute("x2", x2);
        branch.setAttribute("y2", y2);
        growLeaves(svg, x1, y1, x2, y2); // Call function to attach leaves
    }, 50);
}

function drawCircle(svg, x, y, radius, value) {
    let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("data-value", value);
    circle.setAttribute("cx", x);
    circle.setAttribute("cy", y);
    circle.setAttribute("r", 30); // Increased circle size
    circle.setAttribute("fill", "lightblue");

    svg.appendChild(circle);

    let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", x);
    text.setAttribute("y", y + 10); // Adjusted for larger circle
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("font-size", "18px"); // Increased font size
    text.textContent = value;
    svg.appendChild(text);
}

function inorderTraversal(node, result = []) {
    if (!node) return;
    inorderTraversal(node.left, result);
    result.push(node.value);
    inorderTraversal(node.right, result);
    return result;
}

function postorderTraversal(node, result = []) {
    if (!node) return;
    postorderTraversal(node.left, result);
    postorderTraversal(node.right, result);
    result.push(node.value);
    return result;
}

function highlightNodes(values, index = 0) {
    if (index >= values.length) return;
    const value = values[index];
    const circle = document.querySelector(`circle[data-value="${value}"]`);
    if (circle) {
        circle.classList.add('highlight');
        setTimeout(() => circle.classList.remove('highlight'), 1000);
    }
    setTimeout(() => highlightNodes(values, index + 1), 1000);
}

document.getElementById("preorder-btn").addEventListener("click", function() {
    let result = preorderTraversal(avlTree.root, []);
    // ... existing explanation code ...
    highlightNodes(result);
});

document.getElementById("inorder-btn").addEventListener("click", function() {
    let result = inorderTraversal(avlTree.root, []);
    // ... existing explanation code ...
    highlightNodes(result);
});

document.getElementById("postorder-btn").addEventListener("click", function() {
    let result = postorderTraversal(avlTree.root, []);
    // ... existing explanation code ...
    highlightNodes(result);
});

function growLeaves(svg, x1, y1, x2, y2) {
    let branchLength = Math.hypot(x2 - x1, y2 - y1);
    
    if (branchLength < 40) return; // Prevent leaves from growing on short branches

    let leafCount = Math.max(2, Math.min(4, Math.floor(branchLength / 25))); 
    let angle = Math.atan2(y2 - y1, x2 - x1);

    for (let i = 1; i <= leafCount; i++) {
        let t = i / (leafCount + 1); 
        let leafX = x1 + t * (x2 - x1);
        let leafY = y1 + t * (y2 - y1);

        let leftLeaf = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        leftLeaf.setAttribute("cx", leafX - 8 * Math.cos(angle));
        leftLeaf.setAttribute("cy", leafY - 8 * Math.sin(angle));
        leftLeaf.setAttribute("rx", 10);
        leftLeaf.setAttribute("ry", 20);
        leftLeaf.setAttribute("fill", "green");
        leftLeaf.setAttribute("transform", `rotate(${angle * (180 / Math.PI)} ${leafX} ${leafY})`);


        let rightLeaf = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        rightLeaf.setAttribute("cx", leafX + 8 * Math.cos(angle));
        rightLeaf.setAttribute("cy", leafY + 8 * Math.sin(angle));
        rightLeaf.setAttribute("rx", 10);
        rightLeaf.setAttribute("ry", 20);
        rightLeaf.setAttribute("fill", "green");
        rightLeaf.setAttribute("transform", `rotate(${angle * (180 / Math.PI)} ${leafX} ${leafY})`);


        svg.insertBefore(leftLeaf, svg.firstChild);
        svg.insertBefore(rightLeaf, svg.firstChild);




        setTimeout(() => {
            leftLeaf.style.opacity = "1";
            rightLeaf.style.opacity = "1";
        }, 300 + i * 100);
    }
}

function drawNode(svg, node, x, y, offset) {
    if (!node) return;
    let radius = 20;
    if (node.left) {
        drawBranch(svg, x, y, x - offset, y + 60);
        drawNode(svg, node.left, x - offset, y + 60, offset / 1.8); // Adjusted offset division
    }
    if (node.right) {
        drawBranch(svg, x, y, x + offset, y + 60);
        drawNode(svg, node.right, x + offset, y + 60, offset / 1.8); // Adjusted offset division
    }
    drawCircle(svg, x, y, radius, node.value);
}



for (let i = 1; i <= leafCount; i++) {
    let t = i / (leafCount + 1); // Position leaves evenly along the branch
    let leafX = x1 + t * (x2 - x1); // Ensure proper distribution along the branch
    let leafY = y1 + t * (y2 - y1);

    let offset = 12; // Distance from the branch to prevent overlap
    let angle = Math.atan2(y2 - y1, x2 - x1); // Angle of the branch
    let leafOffsetX = Math.cos(angle + Math.PI / 2) * offset;
    let leafOffsetY = Math.sin(angle + Math.PI / 2) * offset;

    // Left-side leaf
    let leftLeaf = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let leftLeafPath = `M ${leafX + leafOffsetX} ${leafY + leafOffsetY} 
                        q -10 -10 -5 -20 
                        q 5 -10 10 0 
                        q 5 10 -5 20 
                        z`;
    leftLeaf.setAttribute("d", leftLeafPath);
    leftLeaf.setAttribute("fill", "green");
    leftLeaf.style.opacity = "0";

    // Right-side leaf (Mirrored on the other side)
    let rightLeaf = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let rightLeafPath = `M ${leafX - leafOffsetX} ${leafY - leafOffsetY} 
                         q 10 -10 5 -20 
                         q -5 -10 -10 0 
                         q -5 10 5 20 
                         z`;
    rightLeaf.setAttribute("d", rightLeafPath);
    rightLeaf.setAttribute("fill", "green");
    rightLeaf.style.opacity = "0";

    svg.appendChild(leftLeaf);
    svg.appendChild(rightLeaf);

    setTimeout(() => {
        leftLeaf.style.opacity = "1"; // Fade in left leaf
        rightLeaf.style.opacity = "1"; // Fade in right leaf
    }, 300 + i * 100); // Staggered leaf growth
}


document.getElementById("preorder-btn").addEventListener("click", function() {
    document.getElementById("explanation-text").innerHTML = 
        "<b>Preorder Traversal:</b> <br> 1. Visit the root. <br> 2. Traverse the left subtree. <br> 3. Traverse the right subtree.";
});

document.getElementById("inorder-btn").addEventListener("click", function() {
    document.getElementById("explanation-text").innerHTML = 
        "<b>Inorder Traversal:</b> <br> 1. Traverse the left subtree. <br> 2. Visit the root. <br> 3. Traverse the right subtree.";
});

document.getElementById("postorder-btn").addEventListener("click", function() {
    document.getElementById("explanation-text").innerHTML = 
        "<b>Postorder Traversal:</b> <br> 1. Traverse the left subtree. <br> 2. Traverse the right subtree. <br> 3. Visit the root.";
});



// Preorder Traversal (Root → Left → Right)
function preorderTraversal(node, result = []) {
    if (!node) return;
    result.push(node.value);
    preorderTraversal(node.left, result);
    preorderTraversal(node.right, result);
    return result;
}

// Function to handle Preorder button click
document.getElementById("preorder-btn").addEventListener("click", function () {
    let result = preorderTraversal(avlTree.root, []);
    if (result.length === 0) {
        document.getElementById("explanation-text").innerText = "Tree is empty.";
    } else {
        document.getElementById("explanation-text").innerText = 
            "Preorder Traversal (Root → Left → Right): " + result.join(" → ");
    }
});




    </script>
</body>
</html>